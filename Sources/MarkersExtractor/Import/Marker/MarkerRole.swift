//
//  MarkerRole.swift
//  MarkersExtractor â€¢ https://github.com/TheAcharya/MarkersExtractor
//  Licensed under MIT License
//

import Foundation

public enum MarkerRole: Hashable, Equatable {
    case video(String)
    case audio(String)
}

extension MarkerRole: CustomStringConvertible {
    public var description: String {
        stringValue
    }
    
    var stringValue: String {
        switch self {
        case let .video(string):
            return string
        case let .audio(string):
            return string
        }
    }
}

extension MarkerRole {
    var isVideo: Bool {
        guard case .video = self else {
            return false
        }
        return true
    }
    
    var isAudio: Bool {
        guard case .audio = self else {
            return false
        }
        return true
    }
}

extension Array where Element == MarkerRole {
    func flattenedString() -> String {
        map { $0.stringValue }
            .joined(separator: ", ")
    }
}

// MARK: MarkerRoles

public struct MarkerRoles: Equatable, Hashable {
    public var video: String
    public var audio: String
    
    public init(video: String = "", audio: String = "",
                collapseClipSubrole: Bool = false) {
        self.audio = audio
        self.video = video
        if collapseClipSubrole { collapseClipSubroles() }
    }
    
    /// Returns FCP's default role(s) for each clip type.
    /// FCP does not write the role to the XML when it does not have a custom role set and is using a default role.
    ///
    /// - Parameter clipType: XML element name. ie: "title" for XML `<title ...>`
    /// - Returns: Role name string. Returns `nil` for unhandled/unrecognized clip types.
    public init?(defaultForClipType clipType: String) {
        switch clipType {
        case "asset-clip":
            self.init(video: "Video")
        case "title":
            self.init(video: "Titles")
        default:
            return nil
        }
    }
    
    /// Strip off subrole if subrole is redundantly generated by FCP.
    /// ie: A role of "Role.Role-1" would return "Role"
    public mutating func collapseClipSubroles() {
        video = Self.collapseClipSubrole(role: video)
        audio = Self.collapseClipSubrole(role: audio)
    }
    
    /// Strip off subrole if subrole is redundantly generated by FCP.
    /// ie: A role of "Role.Role-1" would return "Role"
    public func collapsedClipSubroles() -> Self {
        var copy = self
        copy.collapseClipSubroles()
        return copy
    }
    
    /// Strip off subrole if subrole is redundantly generated by FCP.
    /// ie: A role of "Role.Role-1" would return "Role"
    static func collapseClipSubrole(role: String) -> String {
        let pattern = #"^(.*)\.(.*)-([\d]{1,3})$"#
        let matches = role.regexMatches(captureGroupsFromPattern: pattern)
        guard matches.count == 4,
              let role = matches[1],
              let subrole = matches[2]
                
        else { return role }
        
        if role == subrole { return role }
        return role
    }
}

public enum MarkerRoleType: Equatable, Hashable, CaseIterable {
    case videoRole
    case audioRole
}
